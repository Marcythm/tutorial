#import "mod.typ": *

#show: book.page.with(title: "基本字面量、变量和简单函数")

= 基本字面量、变量和简单函数

Typst很快，并不是因为它的解析器、解释器有世界领先水平的优化，而是因为在Typst脚本的世界，一切都是纯的，没有几乎。

本节根据Typst的底层原理，带你反推和破魅Typst脚本执行逻辑。

== Typst世界的Hello World

在编程界有一个习俗，无论学什么语言，写的第一个程序都将是在一个奇怪的地方输出Hello world。我们入乡随俗，将这个任务稍加改造：使用Typst制作一个输出为“Hello world!!!”的文档。

在Typst的「标记模式」中，要完成这个任务相当容易。根据我们在上一节中学到的知识，我们只需要输入一段文本，即可得到一个输出为“Hello world!!!”的文档：

#code(```typ
Hello world!!!
```)

但是，若对条件稍加限制，仅使用脚本模式完成这个任务，事情就会变得稍显复杂。

#code(```typ
#("Hello " + "world!!!")
```)

事实上，使用脚本模式还可以写出更加奇形怪状的Hello World程序：

#code(```typ
#let hello-world() = {
  "H"; "e"; "l"; "l"; "o"; " "
  "w"; "o"; "r"; "l"; "d"; "!"; "!"; "!"
}
#hello-world()
```)

这三个程序都输出了相同的结果。虽然后两者并不实用，却更能引人思考，理解它们将有助于你掌握Typst脚本的本质。

== 代码表示的自省函数

一个特殊的函数```typ #repr()```来获得字符串的代码表示。

#code(```typ
#[ 一段文本 ]

#repr([ 一段文本 ])
```)

todo更详细的介绍。

== 基本字面量

```typ
#("Hello " + "world!!!")
```

为了知道第二段程序具体做了什么事情，我们需要首先了解Typst中已有的基本字面量。

如果你学过Python等语言，那么这将对你来说不是问题。在Typst中，常用的字面量并不多，它们是：
+ 「整数字面量」（Integer Literal）
+ 「布尔字面量」（Boolean Literal）
+ 「浮点数字面量」（Floating-Point Literal）
+ 「字符串字面量」（String Literal）

=== 「整数字面量」

一个整数字面量常见由一连串数字，以及一个可选的负号组成。相信你一定知道整数的含义。

#code(```typ
三个值 #(-1)、#0 和 #1 偷偷混入了我们内容之中。
```)

注意：有的时候Typst不支持在「井号」后直接跟一个值。这个时候无论值有多么复杂，都可以将值用一对圆括号包裹起来，从而允许Typst轻松解析该值。例如，Typst无法处理「井号」后直接跟随一个「连字符」（`-`）的情况：

#code(```typ
#(-1)
```)

更多示例：

#code(```typ
二进制数：#(0b1001)、#(-0b1001)

八进制数：#(0o755)、#(-0o644)

十六进制数：#(0xdeadbeef)、#(-0xdeadbeef)
```)


=== 「布尔字面量」

一个布尔字面量要么为`false`要么为`true`，它表示逻辑的确否。

#code(```typ
两个值 #false 和 #true 偷偷混入了我们内容之中。
```)

一般来说，我们不直接使用布尔值。当代码做逻辑判断的时候，会自然产生布尔值。

#code(```typ
$1 < 2$的结果为：#(1 < 2)

$1 > 2$的结果为：#(1 > 2)
```)

=== 「浮点数字面量」

#code(```typ
四个值 #(0.001)、#(.1) 和 #(2.) 和 #(1e2) 偷偷混入了我们内容之中。
```)

更多示例：

#code(```typ
科学表示法：#1.926e3

整数除法：#(10 / 4)

$pi$、$tau$、$tau$、$inf$、NaN对应的取值：#calc.pi、#calc.tau、#calc.tau、#calc.inf、#calc.nan
```)

=== 「字符串字面量」

#code(```typ
一个值 #"Hello world!!!" 偷偷混入了我们内容之中。

一个值 #repr("Hello world!!!") 偷偷混入了我们内容之中。
```)

在脚本模式下，字符串由一对「英文双引号」定界。

除了使用简单字面量构造，可以使用以下方法从代码块获得字符串：

#code(```typ
#repr(`Hello world!!!`.text)

#repr(`包含换行符和双引号的

"内容"`.text)
```)

== 表达式、转换和计算库

略

== 回顾第二个Hello World程序

其中，最简单、最容易为大家理解的「值类型」之一应当是「浮点类型」。接下来，让我们具体来看这个示例。

#code(```typ
一个值#0.001偷偷混入了我们内容之中。
```)

这似乎很简单，让我们再看另一个程序，它输出相同的结果：

#code(```typ
一个值#1e-3偷偷混入了我们内容之中。
```)

其中`1e-3`是`0.001`的另一种写法，准确来说`1e-3`是`0.001`的科学表示法。

重点是，我们可以根据文档的输出*反推*出：当Typst处于标记模式下，并看到我们提供的一个「值」的时候，它没有尊重我们的写法，而是将「值」转换成了「内容」再根据内容生成文档。

于是我们可以解释第二个Hello World程序所作的事情：
+ 进入「脚本模式」
+ 创建一个`"Hello world!!!"`字符串字面量。
+ 脚本模式将该字符串“置于原地”，表示希望将这个字符串输出到文档。
+ 脚本结束，Typst自动回到「标记模式」。由于脚本产生的结果不是「内容」而是「值」，Typst将其转换为合适的内容后添加到文档中。

== 变量和简单函数

在Typst中，变量和简单函数有着类似的语法。如下语法，「变量声明」表示使得`x`的内容与`"Hello world!!!"`相等。我们对语法一一翻译：

#code(```typ
   #let    x     =  "Hello world!!!"
// ^^^^    ^     ^  ^^^^^^^^^^^^^^^^ 
//  令    变量名  为      一段内容
```)

可见「变量声明」的语法非常直观。

同时我们看见输出的文档为空，这是因为「变量声明」并不产生任何内容。

变量可以重复输出到文档中：

#code(```typ
#let x = "阿吧"
#x#x，#x#x
```)

上一节所提到的「内容块」也可以赋值给一个变量。

#code(```typ
#let y = [一段文本]
#y
```)

在这里我们同时还介绍Typst中较为直观的「函数声明」：

#code(```typ
   #let    f(x, y)      = [两个值#(x)和#(y)偷偷混入了我们内容之中。]
// ^^^^    ^^^^^^^      ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
//  令  函数名(参数列表)  为               一段内容
```)

同样我们看见输出的文档为空，这是因为「函数声明」也并不产生任何内容。

将对应参数应用于函数可以取得对应的结果：

#code(```typ
#let f(x, y) = [两个值#(x)和#(y)偷偷混入了我们内容之中。]

#let x = "Hello world!!!"
#let y = [一段文本]
#f(repr(x), y)
```)

其中```typ #f(repr(x), y)```的执行过程是这样的：

#```typ
#f(repr(x), y) // 转变为
#f(repr("Hello world!!!"), y) // 转变为
#f([\"Hello world!!!\"], y) // 转变为
#f([\"Hello world!!!\"], [一段文本]) // 转变为
#[两个值#([\"Hello world!!!\"])和#([一段文本])偷偷混入了我们内容之中。] // 转变为
#[两个值\"Hello world!!!\"和一段文本偷偷混入了我们内容之中。] // 转变为
两个值\"Hello world!!!\"和一段文本偷偷混入了我们内容之中。

```

请体会我们在介绍「变量声明」时的特殊措辞，并与「函数声明」的语法描述相对应。

- 以下「变量声明」表示使得`x`的内容与`"Hello world!!!"`相等。

  ```typ
  #let x = "Hello world!!!"
  ```

- 以下「函数声明」表示使得`f(x, y)`的内容与经过计算后的`[两个值#(x)和#(y)偷偷混入了我们内容之中。]`相等。

  ```typ
  #let f(x, y) = [两个值#(x)和#(y)偷偷混入了我们内容之中。]
  ```

== 「可折叠」的值（Foldable）

== 代码块和内容块

在上一节中，我们介绍了「内容块」。但实际上，我们并未对内容块做过多描述。在这里我们将与「代码块」一起详细介绍内容块。

- 内部语法。
  - 代码块：按顺序包含一系列语句，内部为「脚本模式」。
  - 内容块：按顺序包含一系列内容，内部为「标记模式」。
- 执行结果。
  - 代码块：按控制流顺序执行代码，将所有结果折叠成一个值。
    + 例，字符串连接。
    #code(```typ
    #{"Hello"; " "; "World"}
    ```)
    + 例，数组连接。
    #code(```typ
    #for i in range(1, 5) { (i, i * 10) }
    ```)
    + 例，内容连接。以下脚本的每一个“语句”都是内容块，自然也都产生内容：
    #code(```typ
    #{
      [= 生活在Content树上]
      [现代社会以海德格尔的一句“一切实践传统都已经瓦解完了”为嚆矢。]
      [滥觞于家庭与社会传统的期望正失去它们的借鉴意义。]
      [但面对看似无垠的未来天空，我想循卡尔维诺“树上的男爵”的生活好过过早地振翮。]
    }
    ```)
  - 内容块：按文本顺序包含内容，将所有内容折叠成一个内容。
    + 如果遇到一个脚本（以「井号」开始），则立即执行该脚本，并将脚本结果转换成内容。
    + *特别地*，文档本身是一个内容块。

可见在Typst中，代码块和内容块是等同的。甚至，内容块和文档文件本身是等同的。

== 回顾第三个Hello World程序

#let hello-world = ```typ
#let hello-world() = {
  "H"; "e"; "l"; "l"; "o"; " "
  "w"; "o"; "r"; "l"; "d"; "!"; "!"; "!"
}
#hello-world()
```

回顾以下脚本：

#hello-world

首先`hello-world`是一个函数。

当调用该函数时，该函数返回对应代码块的结果。根据「代码块」的特性，代码块产生的结果为所有语句的折叠。

这里所有字符串折叠得到一个完整的字符串`"Hello world!!!"`。

根据我们在第二个Hello World程序中学到的知识，字符串被转换成内容后添加到文档中。

#exec-code(hello-world)

== 时间类型

+ 「日期类型」（`datetime`）

  #code(```typ
  一个值 #datetime(year: 2023, month: 4, day: 19).display() 偷偷混入了我们内容之中。
  ```)

+ 「时间长度类型」（`duration`）

  #code(```typ
  一个值 #duration(days: 3, hours: 10).seconds()s 偷偷混入了我们内容之中。
  ```)
