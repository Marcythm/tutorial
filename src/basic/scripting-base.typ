#import "mod.typ": *

#show: book.page.with(title: "基本字面量、变量和简单函数")

Typst很快，并不是因为它的解析器和解释器具有惊世的性能，而是因为在Typst脚本的世界一切都是纯的，没有几乎。

本节与下一节从Typst的底层原理出发，带你反推和破魅Typst脚本执行逻辑。

== Typst世界的Hello World

编程领域有一个习俗，无论学什么语言，写的第一个程序都将是在一个奇怪的地方输出Hello world。我们入乡随俗，将这个任务稍加改造：使用Typst制作一个内容为“Hello world!!”的文档。

在Typst的「标记模式」中，要完成这个任务相当容易。根据我们在上一节中学到的知识，我们只需要输入一段文本，即可得到一个输出为“Hello world!!”的文档：

#code(```typ
Hello world!!
```)

但是，若对条件稍加限制，仅使用脚本模式完成这个任务，事情就会变得稍显复杂。

#code(```typ
#("Hello " + "world!!")
```)

事实上，使用脚本模式还可以写出更加奇形怪状的Hello World程序：

#code(```typ
#let hello-world() = {
  "H"; "e"; "l"; "l"; "o"; " "
  "w"; "o"; "r"; "l"; "d"; "!"; "!"
}
#hello-world()
```)

这三个程序都输出了相同的结果。虽然后两者并不实用，却更能引人思考，理解它们将有助于你掌握Typst脚本的本质。

== 代码表示的自省函数

在开始学习之前，先学习两个与排版无关但非常实用的函数。

#typst-func("repr")是一个自省函数，可以帮你获得任意值的代码表示。

#code(```typ
#[ 一段文本 ]

#repr([ 一段文本 ])
```)

#typst-func("repr")的特点是可以接受任意值，因此很适合用来在调试代码的时候输出内容。

== 类型的自省函数

与#typst-func("repr")类似，一个特殊的函数#typst-func("type")可以获得任意值的「类型」。

#code(```typ
#type("一个字符串")

#type([一段文本])

#type(() => { "一个函数" })
```)

所谓「类型」，就是这个值归属的分类。例如：1是数字，`一段内容`是文本内容。

因此，类型是可以比较的：

#code(```typ
#(str == str) \
#(type("一个字符串") == type("另一个字符串")) \
#(type("一个字符串") == str) \
#([一段文本] == str)
```)

类型的类型是类型（它自身）：

#code(```typ
#(type(str)) \
#(type(str) == type) \
#(type(type(str)) == type) \
#(type(type(type(str))) == type)
```)

== 求值函数

`eval`函数接受一个字符串，把字符串当作代码执行并求出结果：

#code(```typ
#eval("1"), #type(eval("1")) \
#eval("[一段内容]"), #type(eval("[一段内容]"))
```)

从```typc eval("[一段内容]")```的中括号被看作内容块可以得知，`eval`默认从「脚本模式」开始解释你的代码。

你可以使用`mode`参数修改`eval`的「解释模式」。`markup`对应为「标记模式」：

#code(```typ
代码模式eval：#eval("[一段内容]", mode: "code") \
标记模式eval：#eval("[一段内容]", mode: "markup")
```)

== 基本字面量

```typ
#("Hello " + "world!!")
```

为了搞明白上面的代码，你需要首先了解Typst中已有的基本字面量。

如果你学过Python等语言，那么这将对你来说不是问题。在Typst中，常用的字面量并不多，它们是：
+ 「空字面量」（None Literal）
+ 「布尔字面量」（Boolean Literal）
+ 「整数字面量」（Integer Literal）
+ 「浮点数字面量」（Floating-Point Literal）
+ 「字符串字面量」（String Literal）

=== 「空字面量」

空字面量是纯粹抽象的概念，这意味着你在现实中很难找到对应的实体。就像是数学中的零与负数，空字面量自然产生于运算过程中。

#code(```typ
#repr((0, ).find((_) => false)), 
#repr(if false [啊？])
```)

上例第一行，当在「列表」中查找一个不存在的元素时，“没有”就是```typc none```。

上例第二行，当条件不满足，且没有`false`分支时，“没有内容”就是```typc none```。

这些例子都蕴含较复杂的脚本逻辑，会在下一节详细介绍。

`none`不产生任何内容：

#code(```typ
#none
```)

`none`的类型是`none`类型：

#code(```typ
#type(none)
```)

`none`不等于`none`类型，因为一个是值而另一个是类型：

#code(```typ
#(type(none) == none), #type(none), #type(type(none))
```)

使用以下方法将`none`转化为布尔类型：

#code(```typ
#let some-x = none
#(some-x == none)
#((some-x != none) and (1 < 2))
```)

=== 「布尔字面量」

一个布尔字面量要么为`false`要么为`true`，它表示逻辑的确否。

#code(```typ
两个值 #false 和 #true 偷偷混入了我们内容之中。
```)

一般来说，我们不直接使用布尔值。当代码做逻辑判断的时候，会自然产生布尔值。

#code(```typ
$1 < 2$的结果为：#(1 < 2) \
$1 > 2$的结果为：#(1 > 2)
```)

布尔值的类型是布尔类型：

#code(```typ
#type(false), #type(true)
```)

=== 「整数字面量」

一个整数字面量常见由一连串数字，以及一个可选的负号组成。相信你一定知道整数的含义。Typst中的整数默认为十进制：

#code(```typ
三个值 #(-1)、#0 和 #1 偷偷混入了我们内容之中。
```)

#pro-tip[
  有的时候Typst不支持在「井号」后直接跟一个值。这个时候无论值有多么复杂，都可以将值用一对圆括号包裹起来，从而允许Typst轻松解析该值。例如，Typst无法处理「井号」后直接跟随一个「连字符」（`-`）的情况：

  #code(```typ
  #(-1), #(0), #(1)
  ```)
]

有些数字使用其他进制表示更为方便。你可以分别使用`0x`、`0o`和`0b`前缀加上进制内容表示十六进制数、八进制数和二进制数：

#code(```typ
十六进制数：#(0xdeadbeef)、#(-0xdeadbeef) \
八进制数：#(0o755)、#(-0o644) \
二进制数：#(0b1001)、#(-0b1001)
```)

整数的类型是整数类型：

#code(```typ
#type(0), #type(0x0)
```)

整数的有效取值范围是$[-2^63,2^63)$，其中$2^63=9223372036854775808$。

=== 「浮点数字面量」

浮点数与整数非常类似。最常见的浮点数由一个整数部分与小数部分组成：

#code(```typ
三个值 #(0.001)、#(.1) 和 #(2.) 偷偷混入了我们内容之中。
```)

浮点数的类型是浮点数类型：

#code(```typ
#type(2.)
```)

可见```typc 2.```与```typc 2```类型并不相同。

当数字过大时，其会被隐式转换为浮点数存储：

#code(```typ
#type(9000000000000000000000000000000000000)
```)

整数相除时会被转换为浮点数：

#code(```typ
#(10 / 4), #type(10 / 4) \
#(12 / 4), #type(12 / 4) \
```)

为了转换类型，可以使用`int`，但有可能产生精度损失（就近取整）：

#code(```typ
#int(10 / 4),
#int(12 / 4),
#int(9000000000000000000000000000000000000)
```)

有些数字使用科学表示法更为方便。你可以使用标准的科学表示法创建浮点数：

#code(```typ
#(1e2)、#(1.926e3)、#(-1e-3)
```)

Typst还为你内置了一些特殊的数值，它们都是浮点数：

#code(```typ
$pi$=#calc.pi \
$tau$=#calc.tau \
$inf$=#calc.inf \
NaN=#calc.nan \
```)

=== 「字符串字面量」

Typst中所有字符串都是`utf-8`编码的，因此使用时不存在编码问题。字符串由一对「英文双引号」定界：

#code(```typ
#"Hello world!!"
```)

字符串的类型是字符串类型：

#code(```typ
#type("Hello world!!")
```)

有些字符无法置于双引号之内。例如双引号。这时候你需要嵌入字符的转义序列：

#code(```typ
#"Hello \"world\"!!"
```)

todo: 所有转义序列

与《基础文档》中的转义序列相同，你可以使用`\u{unicode}`格式直接嵌入Unicode字符。

#code(```typ
#"香辣牛肉粉好吃\u{2665}"
```)


除了使用简单字面量构造，可以使用以下方法从代码块获得字符串：

#code(```typ
#repr(`包含换行符和双引号的

"内容"`.text)
```)

== 变量

如下语法，「变量声明」表示使得`x`的内容与`"Hello world!!"`相等。我们对语法一一翻译：

#code(```typ
   #let    x     =  "Hello world!!"
// ^^^^    ^     ^  ^^^^^^^^^^^^^^^^ 
//  令    变量名  为      一段内容
```)

同时我们看见输出的文档为空，这是因为「变量声明」并不产生任何内容。

「变量声明」后续的位置都可以继续使用该变量，取决于「作用域」。

变量可以重复输出到文档中：

#code(```typ
#let x = "阿吧"
#x#x，#x#x
```)

任意时刻都可以将任意类型的值赋给一个变量。上一节所提到的「内容块」也可以赋值给一个变量。

#code(```typ
#let y = [一段文本]
#y \
// 重新赋值为一个整数
#(y = 1)
#y \
```)

// todo: 合法的变量名

== 简单函数

在Typst中，变量和简单函数有着类似的语法。

如下语法，「函数声明」表示使得`f(x, y)`的内容与右侧表达式的值相等。我们对语法一一翻译：

#code(```typ
   #let    f(x, y)      = [两个值#(x)和#(y)偷偷混入了我们内容之中。]
// ^^^^    ^^^^^^^      ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
//  令  函数名(参数列表)  为               一段内容
```)

同样我们看见输出的文档为空，这是因为「函数声明」也并不产生任何内容。

参数列表的长度可以有零个，一个，至任意多个。

#(```typ
// 零个参数
#f()
// 一个参数
#f(x)
// 两个参数
#f(x, y)
// ..
```)

视角挪到等号右侧。右侧可以任意使用参数列表中的“变量”，并组合出一个表达式。表达式的值就是函数调用的结果。

结合例子理解函数的作用。将对应参数应用于函数可以取得对应的结果：

#code(```typ
#let f(x, y) = [两个值#(x)和#(y)偷偷混入了我们内容之中。]

#let x = "Hello world!!"
#let y = [一段文本]
#f(repr(x), y)
```)

其中```typ #f(repr(x), y)```的执行过程是这样的：

```typ
#f(repr(x), y) // 转变为
#f(repr("Hello world!!"), y) // 转变为
#f([\"Hello world!!\"], y) // 转变为
#f([\"Hello world!!\"], [一段文本])
```

注意，此时我们进入右侧表达式。

```typ
#let x = [\"Hello world!!\"]
#let y = [一段文本]
#[两个值#(x)和#(y)偷偷混入了我们内容之中。] // 转变为
#[两个值#([\"Hello world!!\"])和#([一段文本])偷偷混入了我们内容之中。]
```

最后整理式子得到：

```typ
// 转变为
#[两个值\"Hello world!!\"和一段文本偷偷混入了我们内容之中。] // 转变为
两个值\"Hello world!!\"和一段文本偷偷混入了我们内容之中。
```

请体会我们在介绍「变量声明」时的特殊措辞，并与「函数声明」的语法描述相对应。

- 以下「变量声明」表示使得`x`的内容与`"Hello world!!"`相等。

  ```typ
  #let x = "Hello world!!"
  ```

- 以下「函数声明」表示使得`f(x, y)`的内容与经过计算后的`[两个值#(x)和#(y)偷偷混入了我们内容之中。]`相等。

  ```typ
  #let f(x, y) = [两个值#(x)和#(y)偷偷混入了我们内容之中。]
  ```

== 表达式

表达式是以下对象的集合：
+ 前述的各种「字面量」是表达式
  #code(```typ
  // 这些是表达式
  #none, #true, #1, #.2, #"s"
  ```)
+ 「变量」是表达式：
  #code(```typ
  #let a = 1;
  // 这是表达式
  #a
  ```)
+ 「括号表达式」（parenthesized expression）是表达式：
  #code(```typ
  // 这些是表达式
  #(0), #(1+2), #((((((((1))))))))
  ```)
+ 「函数调用」是表达式：
  #code(```typ
  #let add(a, b) = a + b
  #let a = 1;
  // 这是表达式
  #add(a, 2)
  ```)
+ 特别地，Typst中的「代码块」和「内容块」是表达式：
  #code(```typ
  // 这些是表达式
  #repr({ 1 }), #repr([ 1 ]), 
  ```)
+ 特别地，Typst中的「if语句」、「for语句」和「while语句」等都是表达式：
  #code(```typ
  // 这些是表达式
  #repr(if false [啊？]), 
  #repr(for _ in range(0) {}), 
  #repr(while false {}), 
  #repr(let _ = 1), 
  ```)
  这些将在后文中介绍。
+ 情形1至情形7的所有对象作为项，任意项之间的「运算」也是表达式。

其中，情形1至情形3被称为「初始表达式」（primary expression），它们就像是表达式的种子，由其他操作继续组合生成更多表达式。

情形4至情形6本身都是经典意义上的「语句」（statement），它们由一个或多个子表达式组成，形成一个有新含义的表达式。在Typst中它们都被赋予了「值」的语义，因此它们也都是表达式。我们将会在后续文章中继续学习。

#pro-tip[
  Typst借鉴了Rust。遵从「面向表达式编程」（expression-oriented programming）的哲学，它将所有的语句都根据可折叠规则（见后文）转为了表达式。
  + 如果一个语句能产生值，那么该语句的结果是所有值的折叠。
  + 否则，如果一个语句不能产生值，那么该语句的结果是```typc none```。
  特别地，许多类型的折叠符合规则：类型 $T$ 的值 $v$ 与`none`折叠仍然是值本身。
  $ forall v in T union {"none"}, op("fold")_T (v, "none") = v $
]

仅有少量的语句不是表达式。

#pro-tip[
  `show`语句和`set`语句不是表达式。
]

本节主要讲解情形7。由于情形1至情形6都可以作为情形7的项，不失一般性，我们仍然可以仅以「字面量」作为项讲解所有情形7的情况。

=== 逻辑比较表达式

数字之间可以相互（算术逻辑）比较，并产生布尔类型的表达式：

- 小于：
  #code(```typ
  #(1 < 0), #(1 < 1), #(1 < 2)
  ```)
- 小于等于：
  #code(```typ
  #(1 <= 0), #(1 <= 1), #(1 <= 2)
  ```)
- 大于：
  #code(```typ
  #(1 > 0), #(1 > 1), #(1 > 2)
  ```)
- 大于等于：
  #code(```typ
  #(1 >= 0), #(1 >= 1), #(1 >= 2)
  ```)
- 等于：
  #code(```typ
  #(1 == 0), #(1 == 1), #(1 == 2)
  ```)
- 不等于：
  #code(```typ
  #(1 != 0), #(1 != 1), #(1 != 2)
  ```)

不仅整数与整数之间、浮点数与浮点数之间可以做比较，而且整数与浮点数之间也可以做比较。当整数与浮点数相互比较时，整数会转换为浮点数再参与比较。
#code(```typ
#(1 != 0.), #(1 != 1.), #(1 != 2.)
```)

注意：不推荐将整数与浮点数相互比较，这有可能产生意料之外的浮点误差。
#code(```typ
#(9/1e160*1e160), #(9/1e160*1e160 == 9) \
// 理论上为true，实际运算结果为false
#(9/1e160/1e160*1e160*1e160), #(9/1e160/1e160*1e160*1e160 == 9)
```)

=== 逻辑运算表达式

布尔值之间可以做逻辑运算，并产生布尔类型的表达式：

- 且运算：
  #code(```typ
  #(false and false), #(false and true), #(true and false), #(true and true)
  ```)
- 或运算：
  #code(```typ
  #(false or false), #(false or true), #(true or false), #(true or true)
  ```)
- 非运算：
  #code(```typ
  #(not false), #(not true)
  ```)

todo: 逻辑运算介绍，真值表

=== 算术运算表达式

数字之间可以做算术运算，并产生数字结果的表达式：

- 取正运算：
  #code(```typ
  #(+1), #(+0), #(1), #(++1)
  ```)
- 取负运算：
  #code(```typ
  #(-1), #(-0), #(1), #(--1), #(-+-1)
  ```)
- 加运算：
  #code(```typ
  #(1 + 2), #(1 + 1), #(1 + -1), #(1 + -2)
  ```)
- 减运算：
  #code(```typ
  #(1 - 2), #(1 - 1), #(1 - -1), #(1 - -2)
  ```)
- 乘运算：
  #code(```typ
  #(1 * 2), #(2 * 2), #(2 * -2)
  ```)
- 除运算：
  #code(```typ
  #(1 / 2), #(2 / 2), #(2 / -2)
  ```)

todo: 强调-2^63是浮点数，介绍整除

=== 赋值表达式

变量可以被赋予一个表达式的值，所有的赋值表达式都产生`none`值而非返回变量的值。

- 赋值及先加（减、乘或除）后赋值：
  #code(```typ
  #let a = 1
  #repr(a = 10), #a, #repr(a += 2), #a, #repr(a -= 2), #a, #repr(a *= 2), #a, #repr(a /= 2), #a
  ```)

=== 字符串相关的表达式

todo

== 回顾第二个Hello World程序

让我们具体来看这个示例。

#code(```typ
一个值#0.001偷偷混入了我们内容之中。\
一个值#1e-3偷偷混入了我们内容之中。\
```)

其中`1e-3`是`0.001`的另一种写法，准确来说`1e-3`是`0.001`的科学表示法。

我们可以根据文档的输出*反推*出：当Typst处于标记模式下，并看到我们提供的一个「值」的时候，它没有尊重我们的写法，而是将「值」转换成了「内容」再根据内容生成文档。

于是我们可以解释第二个Hello World程序所作的事情：
+ 进入「脚本模式」
+ 创建一个`"Hello "`字符串字面量。
+ 创建一个`"world!!"`字符串字面量。
+ 将这两个字面量相加，得到`"Hello world!!"`字符串字面量。
+ 脚本模式将该字符串“置于原地”，表示希望将这个字符串输出到文档。
+ 脚本结束，Typst自动回到「标记模式」。由于脚本产生的结果不是「内容」而是「值」，Typst将其转换为合适的内容后添加到文档中。

== 类型转换

整数转浮点数：

#code(```typ
#float(1), #(type(float(1)))
```)

布尔值转整数：

#code(```typ
#int(false), #(type(int(false))) \
#int(true), #(type(int(true)))
```)

浮点数转整数：

#code(```typ
#int(1), #(type(int(1)))
```)

该方法是就近取整，并有精度损失（根据规范，超出精度范围时，如何选择较近的值舍入是「与实现相关」）：

#code(```typ
#int(1.5), #int(1.99),
// 超出浮点精度范围会就近舍入再转换成整数
#int(1.9999999999999999)
```)

为了向下或向上取整，你可以同时使用`calc.floor`或`calc.ceil`函数（有精度损失）：

#code(```typ
#int(calc.floor(1.9)), #int(calc.ceil(1.9))
```)

十进制字符串转整数：

#code(```typ
#int("1"), #(type(int("1")))
```)

十六进制/八进制/二进制字符串转整数：

#code(```typ
#let safe-to-int(x) = {
  let res = eval(x)
  assert(type(res) == int, message: "should be integer")
  res
}
#safe-to-int("0xf"), #(type(safe-to-int("0xf"))) \
#safe-to-int("0o755"), #(type(safe-to-int("0o755"))) \
#safe-to-int("0b1011"), #(type(safe-to-int("0b1011"))) \
```)

注意：`assert(type(res) == int)`是必须的，否则是不安全的。

数字转字符串：

#code(```typ
#repr(str(1)), #(type(str(1)))
#repr(str(.5)), #(type(str(.5)))
```)

布尔值转字符串：

#code(```typ
#repr(false), #(type(repr(false)))
```)

数字转布尔值：

#code(```typ
#let to-bool(x) = x != 0
#repr(to-bool(0)), #(type(to-bool(0))) \
#repr(to-bool(1)), #(type(to-bool(1)))
```)

== 计算库

见#link("https://typst.app/docs/reference/foundations/calc")[Typst Reference - Calculation]

== 代码块和内容块

在上一节中，我们介绍了「内容块」，但我们并未对内容块做过多描述。在这里我们将与「代码块」一起详细介绍内容块。

- 内部语法。
  - 代码块：按顺序包含一系列语句，内部为「脚本模式」。
  - 内容块：按顺序包含一系列内容，内部为「标记模式」。

在Typst中，代码块和内容块是等同的。甚至，内容块和文档文件本身是等同的。

== 「可折叠」的值（Foldable）

- 代码块：按控制流顺序执行代码，将所有结果折叠成一个值。
  + 例，字符串连接。
  #code(```typ
  #{"Hello"; " "; "World"}
  ```)
  + 例，数组连接。
  #code(```typ
  #for i in range(1, 5) { (i, i * 10) }
  ```)
  + 例，内容连接。以下脚本的每一个“语句”都是内容块，自然也都产生内容：
  #code(```typ
  #{
    [= 生活在Content树上]
    [现代社会以海德格尔的一句“一切实践传统都已经瓦解完了”为嚆矢。]
    [滥觞于家庭与社会传统的期望正失去它们的借鉴意义。]
    [但面对看似无垠的未来天空，我想循卡尔维诺“树上的男爵”的生活好过过早地振翮。]
  }
  ```)
- 内容块：按文本顺序包含内容，将所有内容折叠成一个内容。
  + 如果遇到一个脚本（以「井号」开始），则立即执行该脚本，并将脚本结果转换成内容。
  + *特别地*，文档本身是一个内容块。

== 回顾第三个Hello World程序

#let hello-world = ```typ
#let hello-world() = {
  "H"; "e"; "l"; "l"; "o"; " "
  "w"; "o"; "r"; "l"; "d"; "!"; "!"
}
#hello-world()
```

回顾以下脚本：

#hello-world

首先`hello-world`是一个函数。

当调用该函数时，该函数返回对应代码块的结果。根据「代码块」的特性，代码块产生的结果为所有语句的折叠。

这里所有字符串折叠得到一个完整的字符串`"Hello world!!"`。

根据我们在第二个Hello World程序中学到的知识，字符串被转换成内容后添加到文档中。

#exec-code(hello-world)
