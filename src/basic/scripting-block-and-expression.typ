#import "mod.typ": *

#show: book.page.with(title: "块与表达式")

== 代码块和内容块 <grammar-code-block>

在上一节中，我们介绍了「内容块」，但我们并未对内容块做过多描述。在这里我们将与「代码块」一起详细介绍内容块。
- 代码块：按顺序包含一系列语句，内部为#term("code mode")。
- 内容块：按顺序包含一系列内容，内部为#term("markup mode")。

内容块（标记模式）内部没有语句的概念，一个个内容或元素按顺序排列。但你可以通过#mark("#")将解释器的「解释模式」从「标记模式」*临时*改为「脚本模式」。当执行完脚本后，将脚本结果转换成内容，并放置在「井号」处。

相比，代码块内部则有语句概念。每个语句可以是换行分隔，也可以是#mark(";")分隔。

#code(```typ
#{
  "a"
  "b"
} \ // 与下表达式等同：
#{ "a"; "b" }
```)

在Typst中，代码块和内容块是等同的。甚至，内容块和文档文件本身是等同的。

内容块的值从感性理解，最终可以形成一个内容。那么代码块的值要如何理解？这就引入了「可折叠」的值（Foldable）的概念。

== 表达式 <scripting-expression>

// 表达式从感性地理解上就是检验执行一段代码是否对应产生一个值。精确来说，表达式是以下对象的集合：
// + 前述的各种「字面量」是表达式：
//   #code(```typ
//   // 这些是表达式
//   #none, #true, #1, #.2, #"s"
//   ```)
// + 「变量」是表达式：
//   #code(```typ
//   #let a = 1;
//   // 这是表达式
//   #a
//   ```)
// + 「括号表达式」（parenthesized expression）是表达式：
//   #code(```typ
//   // 这些是表达式
//   #(0), #(1+2), #((((((((1))))))))
//   ```)
// + 「函数调用」是表达式：
//   #code(```typ
//   #let add(a, b) = a + b
//   #let a = 1;
//   // 这是表达式
//   #add(a, 2)
//   ```)
// + 特别地，Typst中的「代码块」和「内容块」是表达式：
//   #code(```typ
//   // 这些是表达式
//   #repr({ 1 }), #repr([ 1 ]), 
//   ```)
// + 特别地，Typst中的「if语句」、「for语句」和「while语句」等都是表达式：
//   #code(```typ
//   // 这些是表达式
//   #repr(if false [啊？]), 
//   #repr(for _ in range(0) {}), 
//   #repr(while false {}), 
//   #repr(let _ = 1), 
//   ```)
//   这些将在后文中介绍。
// + 情形1至情形7的所有对象作为项，任意项之间的「运算」也是表达式。

其中，情形1至情形3被称为「初始表达式」（primary expression），它们就像是表达式的种子，由其他操作继续组合生成更多表达式。

情形4至情形6本身都是经典意义上的「语句」（statement），它们由一个或多个子表达式组成，形成一个有新含义的表达式。在Typst中它们都被赋予了「值」的语义，因此它们也都是表达式。我们将会在后续文章中继续学习。

#pro-tip[
  Typst借鉴了Rust。遵从「面向表达式编程」（expression-oriented programming）的哲学，它将所有的语句都根据可折叠规则（见后文）转为了表达式。
  + 如果一个语句能产生值，那么该语句的结果是所有值的折叠。
  + 否则，如果一个语句不能产生值，那么该语句的结果是```typc none```。
  特别地，许多类型的折叠符合规则：类型 $T$ 的值 $v$ 与`none`折叠仍然是值本身。
  $ forall v in T union {"none"}, op("fold")_T (v, "none") = v $
]

仅有少量的语句不是表达式。

#pro-tip[
  `show`语句和`set`语句不是表达式。
]

本节主要讲解情形7。由于情形1至情形6都可以作为情形7的项，不失一般性，我们仍然可以仅以「字面量」作为项讲解所有情形7的情况。

=== 逻辑比较表达式 <grammar-logical-cmp-exp>

=== 逻辑运算表达式 <grammar-logical-calc-exp>

=== 算术运算表达式 <grammar-arith-exp>

=== 赋值表达式 <grammar-assign-exp>

=== 字符串相关的表达式

== 「可折叠」的值（Foldable）

先来看代码块。代码块其实就是一个脚本。既然是脚本，Typst就可以按照语句顺序依次执行「语句」。

#pro-tip[
  准确地来说，按照控制流顺序。
]

Typst按控制流顺序执行代码，将所有结果*折叠*成一个值。所谓折叠，就是将所有数值“连接”在一起。这样讲还是太抽象了，来看一个具体的例子。

=== 字符串折叠

Typst实际上不限制代码块的每个语句将会产生什么结果，只要是结果之间可以*折叠*即可。

我们说字符串是可以折叠的：

#code(```typ
#{"Hello"; " "; "World"}
```)

实际上折叠操作基本就是#mark("+")操作。那么字符串的折叠就是在做字符串连接操作：

#code(```typ
#("Hello" + " " + "World")
```)

再看一个例子：

#code(```typ
#{
  let hello = "Hello";
  let space = " ";
  let world = "World";
  hello; space; world;
  let destroy = ", Destroy"
  destroy; space; world; "."
}
```)

如何理解将「变量声明」与表达式混写？

回忆前文。对了，「变量声明」表达式的结果为```typc none```。
#code(```typ
#type(let hello = "Hello")
```)

并且还有一个重点是，字符串与`none`相加是字符串本身，`none`加`none`还是`none`：

#code(```typ
#("Hello" + none), #(none + "Hello"), #repr(none + none)
```)

现在可以重新体会这句话了：Typst按控制流顺序执行代码，将所有结果*折叠*成一个值。对于上例，每句话的执行结果分别是：

```typc
#{
  none; // let hello = "Hello";
  none; // let space = " ";
  none; // let world = "World";
  "Hello"; " "; "World"; // hello; space; world;
  none; // let destroy = ", Destroy"
  ", Destroy"; " "; "Wrold"; "." // destroy; space; world; "."
}
```

将结果收集并“折叠”，得到结果：

#code(```typc
#(none + none + none + "Hello" + " " + "World" + none + ", Destroy" + " " + "Wrold" + ".")
```)

=== 其他基本类型的情况

那么为什么说折叠操作基本就是#mark("+")操作。那么就是说有的“#mark("+")操作”并非是折叠操作。

布尔值、整数和浮点数都不能相互折叠：

```typ
// 不能编译
#{ false; true }; #{ 1; 2 }; #{ 1.; 2. }
```

还有其他可以折叠的值，我们将会在将来学到。

#pro-tip[
  数组与字典是可以折叠的：

  #code(```typ
  #for i in range(1, 5) { (i, i * 10) }
  ```)

  #code(```typ
  #for i in range(1, 5) { let d = (:); d.insert(str(i), i * 10); d }
  ```)
]

那么是否说布尔值、整数和浮点数都不能折叠呢。答案又是否认的，它们都可以与```typc none```折叠（把下面的加号看成折叠操作）：

#code(```typ
#(1 + none)
```)

所以你可以保证一个代码块中只有一个「语句」产生布尔值、整数或浮点数结果，这样的代码块就又是能编译的了。让我们利用`let _ = `来实现这一点：

#code(```typ
#{ let _ = false; true }, #{ 1; let _ = 2 }, #{ let _ = 1.; 2. }
```)

回忆之前所讲的特殊规则：#term("placeholder")用作标识符的作用是“忽略不必要的语句结果”。

=== 内容折叠

Typst脚本的核心重点就在本段。

内容也可以作为代码块的语句结果，这时候内容块的结果是每个语句内容的“折叠”。

#code(```typ
#{
  [= 生活在Content树上]
  [现代社会以海德格尔的一句“一切实践传统都已经瓦解完了”为嚆矢。]
  [滥觞于家庭与社会传统的期望正失去它们的借鉴意义。]
  [但面对看似无垠的未来天空，我想循卡尔维诺“树上的男爵”的生活好过过早地振翮。]
}
```)

是不是感觉很熟悉？实际上内容块就是上述代码块的“糖”。所谓糖就是同一事物更方便书写的语法。上述代码块与下述内容块等价：

#code(```typ
#[
= 生活在Content树上
现代社会以海德格尔的一句“一切实践传统都已经瓦解完了”为嚆矢。滥觞于家庭与社会传统的期望正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循卡尔维诺“树上的男爵”的生活好过过早地振翮。
]
```)

由于Typst默认以「标记模式」开始解释你的文档，这又与省略`#[]`的写法等价：

#code(```typ
= 生活在Content树上
现代社会以海德格尔的一句“一切实践传统都已经瓦解完了”为嚆矢。滥觞于家庭与社会传统的期望正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循卡尔维诺“树上的男爵”的生活好过过早地振翮。
```)

// == Hello World程序

// 有的时候，我们想要访问字面量、变量与函数中存储的“信息”。例如，给定一个字符串```typc "Hello World"```，我们想要截取其中的第二个单词。

// 单词`World`就在那里，但仅凭我们有限的脚本知识，却没有方法得到它。这是因为字符串本身是一个整体，虽然它具备单词信息，我们却缺乏了*访问*信息的方法。

// Typst为我们提供了「成员」和「方法」两种概念访问这些信息。使用「方法」，可以使用以下脚本完成目标：

// #code(```typ
// #"Hello World".split(" ").at(1)
// ```)

// 为了方便讲解，我们改写出6行脚本。除了第二行，每一行都输出一段内容：

// #code(```typ
// #let x = "Hello World"; #x \
// #let split = str.split
// #split(x, " ") \
// #str.split(x, " ") \
// #x.split(" ") \
// #x.split(" ").at(1)
// ```)

// 从```typ #x.split(" ").at(1)```的输出可以看出，这一行帮助我们实现了“截取其中的第二个单词”的目标。我们虽然隐隐约约能揣测出其中的意思：

// ```typ
// #(       x .split(" ")           .at(1)          )
// // 将字符串 根据字符串拆分  取出其中的第2个单词（字符串）
// ```

// 但至少我们对#mark(".")仍是一无所知。

// 本节我们就来讲解Typst中较为高级的脚本语法。这些脚本语法与大部分编程语言的语法相同，但是我们假设你并不知道这些语法。

== `none`类型和`if`语句 <grammar-if>

默认情况下，在逻辑上，Typst按照顺序执行执行你的代码，即先执行前面的语句，再执行后面的语句。开发者如果想要控制程序执行的流程，就必须使用流程控制的语法结构，主要是条件执行和循环执行。

`if`语句用于条件判断，满足条件时，就执行指定的语句。

```typ
#if expression { then-block } else { else-block }
#if expression { then-block }
```

上面式子中，表达式`expression`为真（值为布尔值`true`）时，就执行`then-block`代码块，否则执行`else-block`代码块。特别地，`else`可以省略。

如下所示：

#code(```typ
#(1 < 2) \
#if (1 < 2) { "确实" } else { "啊？" }
```)

因为`1 < 2`表达式为真，所以脚本执行了`then-block`代码块，而忽略了`else-block`代码块，于是最后文档的内容为“确实”。

`if`语句还可以无限串联下去，你可以自行类比推理更长的`if`语句的语义：<grammar-if-if>

```typ
#if expression { .. } else if expression { .. } else { .. }
#if expression { .. } else if expression { .. }
#if expression { .. } else if expression { .. } else if ..
```

这里有一个疑问，如果只写了`then`代码块，而没写`else`代码块，但偏偏表达式不为真，最终脚本会报错吗？请看：

#code(```typ
#if (1 > 2) { "啊？" }
```)

虽然很合理，但是为了学到更多知识，我们用`repr`一探究竟：

#code(```typ
#repr(if (1 > 2) { "啊？" })
```)

当`if`表达式没写`else`代码块而条件为假时，结果为`none`。“none”在中文里意思是“无”，“什么都没有”。同时再次强调`none`在「可折叠」的值中很重要的一个性质：`none`在折叠过程中被忽略。

见下程序，其根据数组所包含的值输出特定字符串：

#code(```typ
#let 查成分(成分数组) = {
  "是个"
  if "A" in 成分数组 { "萌萌" }
  if "C" in 成分数组 { "萌萌" }
  if "G" in 成分数组 { "萌萌" }
  if "T" in 成分数组 { "工具" }
  "人"
}

#查成分(())

#查成分(("A","C",))

#查成分(("A","T",))
```)

由于`if`也是表达式，你可以直接将`if`作为函数体，例如fibnacci函数的递归可以非常简单：

#code(```typ
#let fib(n) = if n <= 1 {
  n
} else {
  fib(n - 1) + fib(n - 2)
}

#fib(46)
```)

== `while`语句 <grammar-while>

// if condition {..}
// if condition [..]
// if condition [..] else {..}
// if condition [..] else if condition {..} else [..]

`while`语句用于循环结构，满足条件时，不断执行循环体。

```typ
#while expression { CONT }
```

上面代码中，如果表达式`expression`为真，就会执行`CONT`代码块，然后再次判断`expression`是否为假；如果`expression`为假就跳出循环，不再执行循环体。

#code(```typ
#{
  let i = 0;
  while i < 10 {
    (i * 2, )
    i += 1;
  }
}
```)

上面代码中，循环体会执行`10`次，每次将`i`增加`1`，直到等于`10`才退出循环。

== `for`语句 <grammar-for>

`for`语句也是常用的循环结构，它迭代访问某个对象的每一项。

```typ
#for X in A { CONT }
```

上面代码中，对于`A`的每一项，都执行`CONT`代码块。在执行`CONT`时，项的内容是`X`。例如以下代码做了与之前循环相同的事情：

#code(```typ
#for i in range(10) {
  (i * 2, )
}
```)

其中`range(10)`创建了一个内容为`(0, 1, 2, ..., 9)`一共10个值的的数组。

所有的数组都可以使用`for`遍历，同理所有字典也都可以使用`for`遍历。在执行`CONT`时，项的内容是键值对，而Typst将用一个数组代表这个键值对，交给你。键值对数组的第0项是键，键值对数组的第1项是对应的值。

#code(```typ
#let cat = (neko-mimi: 2, "utterance": "喵喵喵", attribute: [kawaii\~])
#for i in cat {
  [猫猫的 #i.at(0) 是 #i.at(1)\ ]
}
```)

你可以同时使用「解构赋值」让代码变得更容易阅读：<grammar-for-destruct>

#code(```typ
#let cat = (neko-mimi: 2, "utterance": "喵喵喵", attribute: [kawaii\~])
#for (特色, 这个) in cat {
  [猫猫的 #特色 是 #这个\ ]
}
```)

== `break`语句和`continue`语句 <grammar-break>

无论是`while`还是`for`，都可以使用`break`跳出循环，或`continue`直接进入下一次执行。

基于以下`for`循环，我们探索`break`和`continue`语句的作用。

#code(```typ
#for i in range(10) { (i, ) }
```)

在第一次执行时，如果我们直接使用`break`跳出循环，但是在break之前就已经产生了一些值，那么`for`的结果是`break`前的那些值的「折叠」。

#code(```typ
#for i in range(10) { (i, ); (i + 1926, ); break }
```)

特别地，如果我们直接使用`break`跳出循环，那么`for`的结果是*`none`*。

#code(```typ
#for i in range(10) { break }
```)

在`break`之后的那些值将会被忽略：

#code(```typ
#for i in range(10) { break; (i, ); (i + 1926, ); }
```)

以下代码将收集迭代的所有结果，直到`i >= 5`：
#code(```typ
#for i in range(10) {
  if i >= 5 { break }
  (i, )
}
```)

// #for 方位 in ("东", "南", "西", "北", "中", "间", "东北", "西北", "东南", "西南") [鱼戏莲叶#方位，]

`continue`有相似的规则，便不再赘述。我们举一个例子，以下程序输出在`range(10)`中不是偶数的数字：<grammar-continue>

#code(```typ
#let 是偶数(i) = calc.even(i)
#for i in range(10) {
  if 是偶数(i) { continue }
  (i, )
}
```)

事实上`break`语句和`continue`语句还可以在参数列表中使用，但本书非常不推荐这些写法，因此也不多做介绍：

#code(```typ
#let add(a, b, c) = a + b + c
#while true { add(1, break, 2) }
```)

== 控制函数返回值

你可以通过多种方法控制函数返回值。

=== 占位符 <grammar-placeholder>

早在上节我们就学习过了占位符，这在编写函数体表达式的时候尤为有用。你可以通过占位符忽略不需要的函数返回值。

以下函数获取数组的倒数第二个元素：

#code(```typ
#let last-two(t) = {
  let _ = t.pop()
  t.pop()
}
#last-two((1, 2, 3, 4))
```)

=== `return`语句 <grammar-return>

你可以通过`return`语句忽略表达式其余*所有语句*的结果，而使用`return`语句返回特定的值。

以下函数获取数组的倒数第二个元素：

#code(```typ
#let last-two(t) = {
  t.pop()
  return t.pop()
}
#last-two((1, 2, 3, 4))
```)

== 变量的可变性

Typst对内置实现的所有函数都有良好的自我管理，但总免不了用户打算写一些逆天的函数。为了保证缓存计算仍较为有效，Typst强制要求用户编写的*所有函数*都是纯函数。这允许Typst有效地缓存计算，在相当一部分文档的编译速度上，快过LaTeX等语言上百倍。

你可能不知道所谓的纯函数是为何物，本书也不打算讲解什么是纯函数。关键点是，涉及函数的*纯性*，就涉及到变量的可变性。

相比纯函数，变量的可变性就要好懂多了。

你可以任意改变一个变量的内容，也就是说一个变量默认是可变的：

#code(```typ
#let a = 1; #let b = 2;
#((a, b) = (b, a))
#a, #b \
#for i in range(10) { a += i }
#a, #b
```)

但是，一个函数的函数体表达式不允许涉及到函数体外的变量修改：

#code(```typ
#let a = 1;
#let f() = (a += 1);
// 调用将会产生报错，无法修改`a`变量：
// #f()
```)

这是因为纯函数不允许产生带有副作用的操作。

同时，传递进函数的数组和字典参数都会被拷贝。这将导致对参数数组或参数字典的修改不会影响外部变量的内容：

#code(```typ
#let a = (1, );
#let add-array(a) = (a += (2, ));
#a \ // 初始值
#add-array(a);
#a \ // 函数调用后不发生任何变化
#(a += (2, ));
#a \ // 期望a += (2, )的效果
```)

#pro-tip[
  准确地来说，数组和字典参数会被写时拷贝。所谓写时拷贝，即只有当你期望修改数组和字典参数时，拷贝才会随即发生。
]

为了“修改”外部变量，你必须将修改过的变量设法传出函数，并在外部更新外部变量。

#code(```typ
#let a = (1, );
#let add-array(a) = {
  a += (2, )
  return a
};
#a \ // 初始值
#(a = add-array(a));
#a \ // 返回值更新数组
```)

#pro-tip[
  一个函数是纯的，如果：
  + 对于所有相同参数，返回相同的结果。
  + 函数没有副作用，即局部静态变量、非局部变量、可变引用参数或输入/输出流等状态不会发生变化。

  本节所讲述的内容是对第二点要求的体现。
]
