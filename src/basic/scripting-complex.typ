#import "mod.typ": *

#show: book.page.with(title: "复合字面量、控制流和复杂函数")

= 复合字面量、控制流和复杂函数

== 数组和字典字面量

略

== 控制流

#code(```typ
#if true {
  1
} else {
  0
}
```)

#code(```typ
#let fib(n) = if n <= 1 {
  n
} else {
  fib(n - 1) + fib(n - 2)
}

#fib(46)
```)

#code(```typ
#{
  let i = 0;
  let j = 0;
  while i < 10 {
    j += i;
    i += 1;
  }
  j
}
```)

== 闭包和含变参函数

#code(```typ
#let f = (x, y) => [两个值#(x)和#(y)偷偷混入了我们内容之中。]
#let g(..args) = [很多个值，#args.pos().join([、])，偷偷混入了我们内容之中。]

#f("a", "b")

#g([一个俩个], [仨个四个], [五六七八个])
```)

Typst如何保证一个简单函数甚至是一个闭包是“纯函数”？

答：1. 禁止修改外部变量，则捕获的变量的值是“纯的”或不可变的；2. 折叠的对象是纯的，且「折叠」操作是纯的。

Typst的多文件特性从何而来？

答：1. import函数产生一个模块对象，而模块其实是文件顶层的scope。2. include函数即执行该文件，获得该文件对应的内容块。

基于以上两个特性，Typst为什么快？

+ Typst支持增量解析文件。
+ Typst所有由*用户声明*的函数都是纯的，在其上的调用都是纯的。例如Typst天生支持快速计算递归实现的fibnacci函数：

  #code(```typ
  #let fib(n) = if n <= 1 { n } else { fib(n - 1) + fib(n - 2) }
  #fib(42)
  ```)
+ Typst使用`include`导入其他文件的顶层「内容块」。当其他文件内容未改变时，内容块一定不变，而所有使用到对应内容块的函数的结果也一定不会因此改变。

这意味着，如果你发现了Typst中与一般语言的不同之处，可以思考以上种种优势对用户脚本的增强或限制。
